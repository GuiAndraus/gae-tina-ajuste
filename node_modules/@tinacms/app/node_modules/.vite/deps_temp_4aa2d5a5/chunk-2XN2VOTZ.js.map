{
  "version": 3,
  "sources": ["optional-peer-dep:__vite-optional-peer-dep:graphql-ws:@graphiql/toolkit", "../../../../../@graphiql/toolkit/src/async-helpers/index.ts", "../../../../../meros/node/index.mjs", "../../../../../@n1ru4l/push-pull-async-iterable-iterator/index.mjs", "../../../../../@graphiql/toolkit/src/create-fetcher/lib.ts", "../../../../../@graphiql/toolkit/src/create-fetcher/createFetcher.ts", "../../../../../@graphiql/toolkit/src/format/index.ts", "../../../../../@graphiql/toolkit/src/graphql-helpers/auto-complete.ts", "../../../../../@graphiql/toolkit/src/graphql-helpers/merge-ast.ts", "../../../../../@graphiql/toolkit/src/graphql-helpers/operation-name.ts", "../../../../../@graphiql/toolkit/src/storage/base.ts", "../../../../../@graphiql/toolkit/src/storage/query.ts", "../../../../../@graphiql/toolkit/src/storage/history.ts"],
  "sourcesContent": ["throw new Error(`Could not resolve \"graphql-ws\" imported by \"@graphiql/toolkit\". Is it installed?`)", "import {\r\n  FetcherResult,\r\n  FetcherReturnType,\r\n  Observable,\r\n} from '../create-fetcher';\r\n\r\n// Duck-type promise detection.\r\nexport function isPromise<T>(value: Promise<T> | any): value is Promise<T> {\r\n  return (\r\n    typeof value === 'object' &&\r\n    value !== null &&\r\n    typeof value.then === 'function'\r\n  );\r\n}\r\n\r\n// Duck-type Observable.take(1).toPromise()\r\nfunction observableToPromise<T>(observable: Observable<T>): Promise<T> {\r\n  return new Promise((resolve, reject) => {\r\n    const subscription = observable.subscribe({\r\n      next: v => {\r\n        resolve(v);\r\n        subscription.unsubscribe();\r\n      },\r\n      error: reject,\r\n      complete: () => {\r\n        reject(new Error('no value resolved'));\r\n      },\r\n    });\r\n  });\r\n}\r\n\r\n// Duck-type observable detection.\r\nexport function isObservable<T>(value: any): value is Observable<T> {\r\n  return (\r\n    typeof value === 'object' &&\r\n    value !== null &&\r\n    'subscribe' in value &&\r\n    typeof value.subscribe === 'function'\r\n  );\r\n}\r\n\r\nexport function isAsyncIterable(\r\n  input: unknown,\r\n): input is AsyncIterable<unknown> {\r\n  return (\r\n    typeof input === 'object' &&\r\n    input !== null &&\r\n    // Some browsers still don't have Symbol.asyncIterator implemented (iOS Safari)\r\n    // That means every custom AsyncIterable must be built using a AsyncGeneratorFunction (async function * () {})\r\n    ((input as any)[Symbol.toStringTag] === 'AsyncGenerator' ||\r\n      Symbol.asyncIterator in input)\r\n  );\r\n}\r\n\r\nasync function asyncIterableToPromise<T>(\r\n  input: AsyncIterable<T> | AsyncIterableIterator<T>,\r\n): Promise<T> {\r\n  // Also support AsyncGenerator on Safari iOS.\r\n  // As mentioned in the isAsyncIterable function, there is no Symbol.asyncIterator available,\r\n  // so every AsyncIterable must be implemented using AsyncGenerator.\r\n  const iteratorReturn = (\r\n    'return' in input ? input : input[Symbol.asyncIterator]()\r\n  ).return?.bind(input);\r\n  const iteratorNext = (\r\n    'next' in input ? input : input[Symbol.asyncIterator]()\r\n  ).next.bind(input);\r\n\r\n  const result = await iteratorNext();\r\n  // ensure cleanup\r\n  void iteratorReturn?.();\r\n  return result.value;\r\n}\r\n\r\nexport async function fetcherReturnToPromise(\r\n  fetcherResult: FetcherReturnType,\r\n): Promise<FetcherResult> {\r\n  const result = await fetcherResult;\r\n  if (isAsyncIterable(result)) {\r\n    return asyncIterableToPromise(result);\r\n  }\r\n  if (isObservable(result)) {\r\n    return observableToPromise(result);\r\n  }\r\n  return result;\r\n}\r\n", "async function e(e,t){let n=e.headers[\"content-type\"];if(!n||!~n.indexOf(\"multipart/\"))return e;let r=n.indexOf(\"boundary=\"),i=\"-\";if(~r){let e=r+9,t=n.indexOf(\";\",e);i=n.slice(e,t>-1?t:void 0).trim().replace(/\"/g,\"\")}return async function*(e,t,n){let r,i,f,a=!n||!n.multiple,l=Buffer.byteLength(t),o=Buffer.alloc(0),s=[];e:for await(let n of e){r=o.byteLength,o=Buffer.concat([o,n]);let e=n.indexOf(t);for(~e?r+=e:r=o.indexOf(t),s=[];~r;){let e=o.subarray(0,r),n=o.subarray(r+l);if(i){let t=e.indexOf(\"\\r\\n\\r\\n\")+4,r=e.lastIndexOf(\"\\r\\n\",t),i=!1,l=e.subarray(t,r>-1?void 0:r),o=String(e.subarray(0,t)).trim().split(\"\\r\\n\"),d={},y=o.length;for(;f=o[--y];f=f.split(\": \"),d[f.shift().toLowerCase()]=f.join(\": \"));if(f=d[\"content-type\"],f&&~f.indexOf(\"application/json\"))try{l=JSON.parse(String(l)),i=!0}catch(e){}if(f={headers:d,body:l,json:i},a?yield f:s.push(f),45===n[0]&&45===n[1])break e}else t=\"\\r\\n\"+t,i=l+=2;o=n,r=o.indexOf(t)}s.length&&(yield s)}s.length&&(yield s)}(e,`--${i}`,t)}export{e as meros};", "/**\r\n * Attaches a cleanup handler to a AsyncIterable.\r\n *\r\n * @param source The source that should have a return handler attached\r\n * @param onReturn The return handler that should be attached\r\n * @returns\r\n */\r\nfunction withHandlers(source, onReturn, onThrow) {\r\n    const stream = (async function* withReturnSource() {\r\n        yield* source;\r\n    })();\r\n    const originalReturn = stream.return.bind(stream);\r\n    if (onReturn) {\r\n        stream.return = (...args) => {\r\n            onReturn();\r\n            return originalReturn(...args);\r\n        };\r\n    }\r\n    if (onThrow) {\r\n        const originalThrow = stream.throw.bind(stream);\r\n        stream.throw = (err) => {\r\n            onThrow(err);\r\n            return originalThrow(err);\r\n        };\r\n    }\r\n    return stream;\r\n}\n\nfunction createDeferred() {\r\n    const d = {};\r\n    d.promise = new Promise((resolve, reject) => {\r\n        d.resolve = resolve;\r\n        d.reject = reject;\r\n    });\r\n    return d;\r\n}\r\n/**\r\n * makePushPullAsyncIterableIterator\r\n *\r\n * The iterable will publish values until return or throw is called.\r\n * Afterwards it is in the completed state and cannot be used for publishing any further values.\r\n * It will handle back-pressure and keep pushed values until they are consumed by a source.\r\n */\r\nfunction makePushPullAsyncIterableIterator() {\r\n    let state = {\r\n        type: \"running\" /* running */\r\n    };\r\n    let next = createDeferred();\r\n    const values = [];\r\n    function pushValue(value) {\r\n        if (state.type !== \"running\" /* running */) {\r\n            return;\r\n        }\r\n        values.push(value);\r\n        next.resolve();\r\n        next = createDeferred();\r\n    }\r\n    const source = (async function* PushPullAsyncIterableIterator() {\r\n        while (true) {\r\n            if (values.length > 0) {\r\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n                yield values.shift();\r\n            }\r\n            else {\r\n                if (state.type === \"error\" /* error */) {\r\n                    throw state.error;\r\n                }\r\n                if (state.type === \"finished\" /* finished */) {\r\n                    return;\r\n                }\r\n                await next.promise;\r\n            }\r\n        }\r\n    })();\r\n    const stream = withHandlers(source, () => {\r\n        if (state.type !== \"running\" /* running */) {\r\n            return;\r\n        }\r\n        state = {\r\n            type: \"finished\" /* finished */\r\n        };\r\n        next.resolve();\r\n    }, (error) => {\r\n        if (state.type !== \"running\" /* running */) {\r\n            return;\r\n        }\r\n        state = {\r\n            type: \"error\" /* error */,\r\n            error\r\n        };\r\n        next.resolve();\r\n    });\r\n    return {\r\n        pushValue,\r\n        asyncIterableIterator: stream\r\n    };\r\n}\n\nconst makeAsyncIterableIteratorFromSink = (make) => {\r\n    const { pushValue, asyncIterableIterator } = makePushPullAsyncIterableIterator();\r\n    const dispose = make({\r\n        next: (value) => {\r\n            pushValue(value);\r\n        },\r\n        complete: () => {\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            asyncIterableIterator.return();\r\n        },\r\n        error: (err) => {\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            asyncIterableIterator.throw(err);\r\n        }\r\n    });\r\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n    const originalReturn = asyncIterableIterator.return;\r\n    let returnValue = undefined;\r\n    asyncIterableIterator.return = () => {\r\n        if (returnValue === undefined) {\r\n            dispose();\r\n            returnValue = originalReturn();\r\n        }\r\n        return returnValue;\r\n    };\r\n    return asyncIterableIterator;\r\n};\n\nfunction applyAsyncIterableIteratorToSink(asyncIterableIterator, sink) {\r\n    const run = async () => {\r\n        try {\r\n            for await (const value of asyncIterableIterator) {\r\n                sink.next(value);\r\n            }\r\n            sink.complete();\r\n        }\r\n        catch (err) {\r\n            sink.error(err);\r\n        }\r\n    };\r\n    run();\r\n    return () => {\r\n        var _a;\r\n        (_a = asyncIterableIterator.return) === null || _a === void 0 ? void 0 : _a.call(asyncIterableIterator);\r\n    };\r\n}\n\nfunction isAsyncIterable(input) {\r\n    return (typeof input === \"object\" &&\r\n        input !== null &&\r\n        // The AsyncGenerator check is for Safari on iOS which currently does not have\r\n        // Symbol.asyncIterator implemented\r\n        // That means every custom AsyncIterable must be built using a AsyncGeneratorFunction (async function * () {})\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        (input[Symbol.toStringTag] === \"AsyncGenerator\" ||\r\n            (Symbol.asyncIterator && Symbol.asyncIterator in input)));\r\n}\n\n/**\r\n * Attaches a cleanup handler from and AsyncIterable to an AsyncIterable.\r\n *\r\n * @param source\r\n * @param target\r\n */\r\nfunction withHandlersFrom(\r\n/** The source that should be returned with attached handlers. */\r\nsource, \r\n/**The target on which the return and throw methods should be called. */\r\ntarget) {\r\n    return withHandlers(source, () => { var _a; return (_a = target.return) === null || _a === void 0 ? void 0 : _a.call(target); }, err => { var _a; return (_a = target.throw) === null || _a === void 0 ? void 0 : _a.call(target, err); });\r\n}\n\nfunction filter(filter) {\r\n    return async function* filterGenerator(asyncIterable) {\r\n        for await (const value of asyncIterable) {\r\n            if (filter(value)) {\r\n                yield value;\r\n            }\r\n        }\r\n    };\r\n}\n\n/**\r\n * Map the events published by an AsyncIterable.\r\n */\r\nconst map = (map) => async function* mapGenerator(asyncIterable) {\r\n    for await (const value of asyncIterable) {\r\n        yield map(value);\r\n    }\r\n};\n\nexport { applyAsyncIterableIteratorToSink, filter, isAsyncIterable, makeAsyncIterableIteratorFromSink, makePushPullAsyncIterableIterator, map, withHandlers, withHandlersFrom };\n", "import { DocumentNode, visit } from 'graphql';\r\nimport { meros } from 'meros';\r\nimport {\r\n  Client,\r\n  ClientOptions,\r\n  ExecutionResult,\r\n  createClient as createClientType,\r\n} from 'graphql-ws';\r\nimport {\r\n  isAsyncIterable,\r\n  makeAsyncIterableIteratorFromSink,\r\n} from '@n1ru4l/push-pull-async-iterable-iterator';\r\n\r\nimport type {\r\n  Fetcher,\r\n  FetcherParams,\r\n  FetcherOpts,\r\n  ExecutionResultPayload,\r\n  CreateFetcherOptions,\r\n} from './types';\r\n\r\nconst errorHasCode = (err: unknown): err is { code: string } => {\r\n  return typeof err === 'object' && err !== null && 'code' in err;\r\n};\r\n\r\n/**\r\n * Returns true if the name matches a subscription in the AST\r\n *\r\n * @param document {DocumentNode}\r\n * @param name the operation name to lookup\r\n * @returns {boolean}\r\n */\r\nexport const isSubscriptionWithName = (\r\n  document: DocumentNode,\r\n  name: string | undefined,\r\n): boolean => {\r\n  let isSubscription = false;\r\n  visit(document, {\r\n    OperationDefinition(node) {\r\n      if (name === node.name?.value && node.operation === 'subscription') {\r\n        isSubscription = true;\r\n      }\r\n    },\r\n  });\r\n  return isSubscription;\r\n};\r\n\r\n/**\r\n * create a simple HTTP/S fetcher using a fetch implementation where\r\n * multipart is not needed\r\n *\r\n * @param options {CreateFetcherOptions}\r\n * @param httpFetch {typeof fetch}\r\n * @returns {Fetcher}\r\n */\r\nexport const createSimpleFetcher =\r\n  (options: CreateFetcherOptions, httpFetch: typeof fetch): Fetcher =>\r\n  async (graphQLParams: FetcherParams, fetcherOpts?: FetcherOpts) => {\r\n    const data = await httpFetch(options.url, {\r\n      method: 'POST',\r\n      body: JSON.stringify(graphQLParams),\r\n      headers: {\r\n        'content-type': 'application/json',\r\n        ...options.headers,\r\n        ...fetcherOpts?.headers,\r\n      },\r\n    });\r\n    return data.json();\r\n  };\r\n\r\nexport const createWebsocketsFetcherFromUrl = (\r\n  url: string,\r\n  connectionParams?: ClientOptions['connectionParams'],\r\n) => {\r\n  let wsClient;\r\n  try {\r\n    const { createClient } = require('graphql-ws') as {\r\n      createClient: typeof createClientType;\r\n    };\r\n\r\n    // TODO: defaults?\r\n    wsClient = createClient({\r\n      url,\r\n      connectionParams,\r\n    });\r\n    return createWebsocketsFetcherFromClient(wsClient);\r\n  } catch (err) {\r\n    if (errorHasCode(err) && err.code === 'MODULE_NOT_FOUND') {\r\n      throw new Error(\r\n        \"You need to install the 'graphql-ws' package to use websockets when passing a 'subscriptionUrl'\",\r\n      );\r\n    }\r\n    // eslint-disable-next-line no-console\r\n    console.error(`Error creating websocket client for ${url}`, err);\r\n  }\r\n};\r\n\r\n/**\r\n * Create ws/s fetcher using provided wsClient implementation\r\n *\r\n * @param wsClient {Client}\r\n * @returns {Fetcher}\r\n */\r\nexport const createWebsocketsFetcherFromClient =\r\n  (wsClient: Client) => (graphQLParams: FetcherParams) =>\r\n    makeAsyncIterableIteratorFromSink<ExecutionResult>(sink =>\r\n      wsClient.subscribe(graphQLParams, {\r\n        ...sink,\r\n        error: err => {\r\n          if (err instanceof CloseEvent) {\r\n            sink.error(\r\n              new Error(\r\n                `Socket closed with event ${err.code} ${\r\n                  err.reason || ''\r\n                }`.trim(),\r\n              ),\r\n            );\r\n          } else {\r\n            sink.error(err);\r\n          }\r\n        },\r\n      }),\r\n    );\r\n\r\n/**\r\n * Allow legacy websockets protocol client, but no definitions for it,\r\n * as the library is deprecated and has security issues\r\n *\r\n * @param legacyWsClient\r\n * @returns\r\n */\r\nexport const createLegacyWebsocketsFetcher =\r\n  (legacyWsClient: { request: (params: FetcherParams) => unknown }) =>\r\n  (graphQLParams: FetcherParams) => {\r\n    const observable = legacyWsClient.request(graphQLParams);\r\n    return makeAsyncIterableIteratorFromSink<ExecutionResult>(\r\n      // @ts-ignore\r\n      sink => observable.subscribe(sink).unsubscribe,\r\n    );\r\n  };\r\n/**\r\n * create a fetcher with the `IncrementalDelivery` HTTP/S spec for\r\n * `@stream` and `@defer` support using `fetch-multipart-graphql`\r\n *\r\n * @param options {CreateFetcherOptions}\r\n * @returns {Fetcher}\r\n */\r\nexport const createMultipartFetcher = (\r\n  options: CreateFetcherOptions,\r\n  httpFetch: typeof fetch,\r\n): Fetcher =>\r\n  async function* (graphQLParams: FetcherParams, fetcherOpts?: FetcherOpts) {\r\n    const response = await httpFetch(options.url, {\r\n      method: 'POST',\r\n      body: JSON.stringify(graphQLParams),\r\n      headers: {\r\n        'content-type': 'application/json',\r\n        accept: 'application/json, multipart/mixed',\r\n        ...options.headers,\r\n        // allow user-defined headers to override\r\n        // the static provided headers\r\n        ...fetcherOpts?.headers,\r\n      },\r\n    }).then(r =>\r\n      meros<Extract<ExecutionResultPayload, { hasNext: boolean }>>(r, {\r\n        multiple: true,\r\n      }),\r\n    );\r\n\r\n    // Follows the same as createSimpleFetcher above, in that we simply return it as json.\r\n    if (!isAsyncIterable(response)) {\r\n      return yield response.json();\r\n    }\r\n\r\n    for await (const chunk of response) {\r\n      if (chunk.some(part => !part.json)) {\r\n        const message = chunk.map(\r\n          part => `Headers::\\n${part.headers}\\n\\nBody::\\n${part.body}`,\r\n        );\r\n        throw new Error(\r\n          `Expected multipart chunks to be of json type. got:\\n${message}`,\r\n        );\r\n      }\r\n      yield chunk.map(part => part.body);\r\n    }\r\n  };\r\n\r\n/**\r\n * If `wsClient` or `legacyClient` are provided, then `subscriptionUrl` is overridden.\r\n * @param options {CreateFetcherOptions}\r\n * @returns\r\n */\r\nexport const getWsFetcher = (\r\n  options: CreateFetcherOptions,\r\n  fetcherOpts: FetcherOpts | undefined,\r\n) => {\r\n  if (options.wsClient) {\r\n    return createWebsocketsFetcherFromClient(options.wsClient);\r\n  }\r\n  if (options.subscriptionUrl) {\r\n    return createWebsocketsFetcherFromUrl(options.subscriptionUrl, {\r\n      ...options.wsConnectionParams,\r\n      ...fetcherOpts?.headers,\r\n    });\r\n  }\r\n  const legacyWebsocketsClient = options.legacyClient || options.legacyWsClient;\r\n  if (legacyWebsocketsClient) {\r\n    return createLegacyWebsocketsFetcher(legacyWebsocketsClient);\r\n  }\r\n};\r\n", "import type { Fetcher, CreateFetcherOptions } from './types';\r\n\r\nimport {\r\n  createMultipartFetcher,\r\n  createSimpleFetcher,\r\n  isSubscriptionWithName,\r\n  getWsFetcher,\r\n} from './lib';\r\n\r\n/**\r\n * build a GraphiQL fetcher that is:\r\n * - backwards compatible\r\n * - optionally supports graphql-ws or `\r\n *\r\n * @param options {CreateFetcherOptions}\r\n * @returns {Fetcher}\r\n */\r\nexport function createGraphiQLFetcher(options: CreateFetcherOptions): Fetcher {\r\n  let httpFetch;\r\n  if (typeof window !== 'undefined' && window.fetch) {\r\n    httpFetch = window.fetch;\r\n  }\r\n  if (\r\n    options?.enableIncrementalDelivery === null ||\r\n    options.enableIncrementalDelivery !== false\r\n  ) {\r\n    options.enableIncrementalDelivery = true;\r\n  }\r\n  if (options.fetch) {\r\n    httpFetch = options.fetch;\r\n  }\r\n  if (!httpFetch) {\r\n    throw new Error('No valid fetcher implementation available');\r\n  }\r\n  // simpler fetcher for schema requests\r\n  const simpleFetcher = createSimpleFetcher(options, httpFetch);\r\n\r\n  const httpFetcher = options.enableIncrementalDelivery\r\n    ? createMultipartFetcher(options, httpFetch)\r\n    : simpleFetcher;\r\n\r\n  return (graphQLParams, fetcherOpts) => {\r\n    if (graphQLParams.operationName === 'IntrospectionQuery') {\r\n      return (options.schemaFetcher || simpleFetcher)(\r\n        graphQLParams,\r\n        fetcherOpts,\r\n      );\r\n    }\r\n    const isSubscription = fetcherOpts?.documentAST\r\n      ? isSubscriptionWithName(\r\n          fetcherOpts.documentAST,\r\n          graphQLParams.operationName || undefined,\r\n        )\r\n      : false;\r\n    if (isSubscription) {\r\n      const wsFetcher = getWsFetcher(options, fetcherOpts);\r\n\r\n      if (!wsFetcher) {\r\n        throw new Error(\r\n          `Your GraphiQL createFetcher is not properly configured for websocket subscriptions yet. ${\r\n            options.subscriptionUrl\r\n              ? `Provided URL ${options.subscriptionUrl} failed`\r\n              : `Please provide subscriptionUrl, wsClient or legacyClient option first.`\r\n          }`,\r\n        );\r\n      }\r\n      return wsFetcher(graphQLParams);\r\n    }\r\n    return httpFetcher(graphQLParams, fetcherOpts);\r\n  };\r\n}\r\n", "function stringify(obj: unknown): string {\r\n  return JSON.stringify(obj, null, 2);\r\n}\r\n\r\nfunction formatSingleError(error: Error): Error {\r\n  return {\r\n    ...error,\r\n    // Raise these details even if they're non-enumerable\r\n    message: error.message,\r\n    stack: error.stack,\r\n  };\r\n}\r\n\r\nfunction handleSingleError(error: unknown) {\r\n  if (error instanceof Error) {\r\n    return formatSingleError(error);\r\n  }\r\n  return error;\r\n}\r\n\r\nexport function formatError(error: unknown): string {\r\n  if (Array.isArray(error)) {\r\n    return stringify({\r\n      errors: error.map(e => handleSingleError(e)),\r\n    });\r\n  }\r\n  return stringify({ errors: [handleSingleError(error)] });\r\n}\r\n\r\nexport function formatResult(result: any): string {\r\n  return stringify(result);\r\n}\r\n", "import {\r\n  DocumentNode,\r\n  getNamedType,\r\n  GraphQLOutputType,\r\n  GraphQLSchema,\r\n  GraphQLType,\r\n  isLeafType,\r\n  Kind,\r\n  parse,\r\n  print,\r\n  SelectionSetNode,\r\n  TypeInfo,\r\n  visit,\r\n} from 'graphql';\r\n\r\ntype Insertion = {\r\n  index: number;\r\n  string: string;\r\n};\r\n\r\nexport type GetDefaultFieldNamesFn = (type: GraphQLType) => string[];\r\n\r\n/**\r\n * Given a document string which may not be valid due to terminal fields not\r\n * representing leaf values (Spec Section: \"Leaf Field Selections\"), and a\r\n * function which provides reasonable default field names for a given type,\r\n * this function will attempt to produce a schema which is valid after filling\r\n * in selection sets for the invalid fields.\r\n *\r\n * Note that there is no guarantee that the result will be a valid query, this\r\n * utility represents a \"best effort\" which may be useful within IDE tools.\r\n */\r\nexport function fillLeafs(\r\n  schema?: GraphQLSchema | null,\r\n  docString?: string,\r\n  getDefaultFieldNames?: GetDefaultFieldNamesFn,\r\n) {\r\n  const insertions: Insertion[] = [];\r\n\r\n  if (!schema || !docString) {\r\n    return { insertions, result: docString };\r\n  }\r\n\r\n  let ast: DocumentNode;\r\n  try {\r\n    ast = parse(docString);\r\n  } catch {\r\n    return { insertions, result: docString };\r\n  }\r\n\r\n  const fieldNameFn = getDefaultFieldNames || defaultGetDefaultFieldNames;\r\n  const typeInfo = new TypeInfo(schema);\r\n  visit(ast, {\r\n    leave(node) {\r\n      typeInfo.leave(node);\r\n    },\r\n    enter(node) {\r\n      typeInfo.enter(node);\r\n      if (node.kind === 'Field' && !node.selectionSet) {\r\n        const fieldType = typeInfo.getType();\r\n        const selectionSet = buildSelectionSet(\r\n          isFieldType(fieldType) as GraphQLOutputType,\r\n          fieldNameFn,\r\n        );\r\n        if (selectionSet && node.loc) {\r\n          const indent = getIndentation(docString, node.loc.start);\r\n          insertions.push({\r\n            index: node.loc.end,\r\n            string: ' ' + print(selectionSet).replaceAll('\\n', '\\n' + indent),\r\n          });\r\n        }\r\n      }\r\n    },\r\n  });\r\n\r\n  // Apply the insertions, but also return the insertions metadata.\r\n  return {\r\n    insertions,\r\n    result: withInsertions(docString, insertions),\r\n  };\r\n}\r\n\r\n// The default function to use for producing the default fields from a type.\r\n// This function first looks for some common patterns, and falls back to\r\n// including all leaf-type fields.\r\nfunction defaultGetDefaultFieldNames(type: GraphQLType) {\r\n  // If this type cannot access fields, then return an empty set.\r\n  // if (!type.getFields) {\r\n  if (!('getFields' in type)) {\r\n    return [];\r\n  }\r\n\r\n  const fields = type.getFields();\r\n\r\n  // Is there an `id` field?\r\n  if (fields.id) {\r\n    return ['id'];\r\n  }\r\n\r\n  // Is there an `edges` field?\r\n  if (fields.edges) {\r\n    return ['edges'];\r\n  }\r\n\r\n  // Is there an `node` field?\r\n  if (fields.node) {\r\n    return ['node'];\r\n  }\r\n\r\n  // Include all leaf-type fields.\r\n  const leafFieldNames: Array<string> = [];\r\n  for (const fieldName of Object.keys(fields)) {\r\n    if (isLeafType(fields[fieldName].type)) {\r\n      leafFieldNames.push(fieldName);\r\n    }\r\n  }\r\n  return leafFieldNames;\r\n}\r\n\r\n// Given a GraphQL type, and a function which produces field names, recursively\r\n// generate a SelectionSet which includes default fields.\r\nfunction buildSelectionSet(\r\n  type: GraphQLOutputType,\r\n  getDefaultFieldNames: GetDefaultFieldNamesFn,\r\n): SelectionSetNode | undefined {\r\n  // Unwrap any non-null or list types.\r\n  const namedType = getNamedType(type);\r\n\r\n  // Unknown types and leaf types do not have selection sets.\r\n  if (!type || isLeafType(type)) {\r\n    return;\r\n  }\r\n\r\n  // Get an array of field names to use.\r\n  const fieldNames = getDefaultFieldNames(namedType);\r\n\r\n  // If there are no field names to use, return no selection set.\r\n  if (\r\n    !Array.isArray(fieldNames) ||\r\n    fieldNames.length === 0 ||\r\n    !('getFields' in namedType)\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  // Build a selection set of each field, calling buildSelectionSet recursively.\r\n  return {\r\n    kind: Kind.SELECTION_SET,\r\n    selections: fieldNames.map(fieldName => {\r\n      const fieldDef = namedType.getFields()[fieldName];\r\n      const fieldType = fieldDef ? fieldDef.type : null;\r\n      return {\r\n        kind: Kind.FIELD,\r\n        name: {\r\n          kind: Kind.NAME,\r\n          value: fieldName,\r\n        },\r\n        // we can use as here, because we already know that fieldType\r\n        // comes from an origin parameter\r\n        selectionSet: buildSelectionSet(\r\n          fieldType as GraphQLOutputType,\r\n          getDefaultFieldNames,\r\n        ),\r\n      };\r\n    }),\r\n  };\r\n}\r\n\r\n// Given an initial string, and a list of \"insertion\" { index, string } objects,\r\n// return a new string with these insertions applied.\r\nfunction withInsertions(initial: string, insertions: Insertion[]) {\r\n  if (insertions.length === 0) {\r\n    return initial;\r\n  }\r\n  let edited = '';\r\n  let prevIndex = 0;\r\n  for (const { index, string } of insertions) {\r\n    edited += initial.slice(prevIndex, index) + string;\r\n    prevIndex = index;\r\n  }\r\n  edited += initial.slice(prevIndex);\r\n  return edited;\r\n}\r\n\r\n// Given a string and an index, look backwards to find the string of whitespace\r\n// following the next previous line break.\r\nfunction getIndentation(str: string, index: number) {\r\n  let indentStart = index;\r\n  let indentEnd = index;\r\n  while (indentStart) {\r\n    const c = str.charCodeAt(indentStart - 1);\r\n    // line break\r\n    if (c === 10 || c === 13 || c === 0x2028 || c === 0x2029) {\r\n      break;\r\n    }\r\n    indentStart--;\r\n    // not white space\r\n    if (c !== 9 && c !== 11 && c !== 12 && c !== 32 && c !== 160) {\r\n      indentEnd = indentStart;\r\n    }\r\n  }\r\n  return str.slice(indentStart, indentEnd);\r\n}\r\n\r\nfunction isFieldType(\r\n  fieldType: GraphQLOutputType | null | undefined,\r\n): GraphQLOutputType | void {\r\n  if (fieldType) {\r\n    return fieldType;\r\n  }\r\n}\r\n", "import {\r\n  DocumentNode,\r\n  FieldNode,\r\n  FragmentDefinitionNode,\r\n  GraphQLOutputType,\r\n  GraphQLSchema,\r\n  SelectionNode,\r\n  TypeInfo,\r\n  getNamedType,\r\n  visit,\r\n  visitWithTypeInfo,\r\n  ASTVisitor,\r\n  Kind,\r\n} from 'graphql';\r\n\r\nfunction uniqueBy<T>(\r\n  array: readonly SelectionNode[],\r\n  iteratee: (item: FieldNode) => T,\r\n) {\r\n  const FilteredMap = new Map<T, FieldNode>();\r\n  const result: SelectionNode[] = [];\r\n  for (const item of array) {\r\n    if (item.kind === 'Field') {\r\n      const uniqueValue = iteratee(item);\r\n      const existing = FilteredMap.get(uniqueValue);\r\n      if (item.directives?.length) {\r\n        // Cannot inline fields with directives (yet)\r\n        const itemClone = { ...item };\r\n        result.push(itemClone);\r\n      } else if (existing?.selectionSet && item.selectionSet) {\r\n        // Merge the selection sets\r\n        existing.selectionSet.selections = [\r\n          ...existing.selectionSet.selections,\r\n          ...item.selectionSet.selections,\r\n        ];\r\n      } else if (!existing) {\r\n        const itemClone = { ...item };\r\n        FilteredMap.set(uniqueValue, itemClone);\r\n        result.push(itemClone);\r\n      }\r\n    } else {\r\n      result.push(item);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction inlineRelevantFragmentSpreads(\r\n  fragmentDefinitions: {\r\n    [key: string]: FragmentDefinitionNode | undefined;\r\n  },\r\n  selections: readonly SelectionNode[],\r\n  selectionSetType?: GraphQLOutputType | null,\r\n): readonly SelectionNode[] {\r\n  const selectionSetTypeName = selectionSetType\r\n    ? getNamedType(selectionSetType).name\r\n    : null;\r\n  const outputSelections = [];\r\n  const seenSpreads: string[] = [];\r\n  for (let selection of selections) {\r\n    if (selection.kind === 'FragmentSpread') {\r\n      const fragmentName = selection.name.value;\r\n      if (!selection.directives || selection.directives.length === 0) {\r\n        if (seenSpreads.includes(fragmentName)) {\r\n          /* It's a duplicate - skip it! */\r\n          continue;\r\n        } else {\r\n          seenSpreads.push(fragmentName);\r\n        }\r\n      }\r\n      const fragmentDefinition = fragmentDefinitions[selection.name.value];\r\n      if (fragmentDefinition) {\r\n        const { typeCondition, directives, selectionSet } = fragmentDefinition;\r\n        selection = {\r\n          kind: Kind.INLINE_FRAGMENT,\r\n          typeCondition,\r\n          directives,\r\n          selectionSet,\r\n        };\r\n      }\r\n    }\r\n    if (\r\n      selection.kind === Kind.INLINE_FRAGMENT &&\r\n      // Cannot inline if there are directives\r\n      (!selection.directives || selection.directives?.length === 0)\r\n    ) {\r\n      const fragmentTypeName = selection.typeCondition\r\n        ? selection.typeCondition.name.value\r\n        : null;\r\n      if (!fragmentTypeName || fragmentTypeName === selectionSetTypeName) {\r\n        outputSelections.push(\r\n          ...inlineRelevantFragmentSpreads(\r\n            fragmentDefinitions,\r\n            selection.selectionSet.selections,\r\n            selectionSetType,\r\n          ),\r\n        );\r\n        continue;\r\n      }\r\n    }\r\n    outputSelections.push(selection);\r\n  }\r\n  return outputSelections;\r\n}\r\n\r\n/**\r\n * Given a document AST, inline all named fragment definitions.\r\n */\r\nexport function mergeAst(\r\n  documentAST: DocumentNode,\r\n  schema?: GraphQLSchema | null,\r\n): DocumentNode {\r\n  // If we're given the schema, we can simplify even further by resolving object\r\n  // types vs unions/interfaces\r\n  const typeInfo = schema ? new TypeInfo(schema) : null;\r\n\r\n  const fragmentDefinitions: {\r\n    [key: string]: FragmentDefinitionNode | undefined;\r\n  } = Object.create(null);\r\n\r\n  for (const definition of documentAST.definitions) {\r\n    if (definition.kind === Kind.FRAGMENT_DEFINITION) {\r\n      fragmentDefinitions[definition.name.value] = definition;\r\n    }\r\n  }\r\n\r\n  const visitors: ASTVisitor = {\r\n    SelectionSet(node: any) {\r\n      const selectionSetType = typeInfo ? typeInfo.getParentType() : null;\r\n      let { selections } = node;\r\n\r\n      selections = inlineRelevantFragmentSpreads(\r\n        fragmentDefinitions,\r\n        selections,\r\n        selectionSetType,\r\n      );\r\n\r\n      selections = uniqueBy(selections, selection =>\r\n        selection.alias ? selection.alias.value : selection.name.value,\r\n      );\r\n\r\n      return {\r\n        ...node,\r\n        selections,\r\n      };\r\n    },\r\n    FragmentDefinition() {\r\n      return null;\r\n    },\r\n  };\r\n\r\n  return visit(\r\n    documentAST,\r\n    typeInfo ? visitWithTypeInfo(typeInfo, visitors) : visitors,\r\n  );\r\n}\r\n", "import { OperationDefinitionNode } from 'graphql';\r\n\r\n/**\r\n * Provided optional previous operations and selected name, and a next list of\r\n * operations, determine what the next selected operation should be.\r\n */\r\nexport function getSelectedOperationName(\r\n  prevOperations?: OperationDefinitionNode[] | undefined,\r\n  prevSelectedOperationName?: string,\r\n  operations?: OperationDefinitionNode[],\r\n) {\r\n  // If there are not enough operations to bother with, return nothing.\r\n  if (!operations || operations.length < 1) {\r\n    return;\r\n  }\r\n\r\n  // If a previous selection still exists, continue to use it.\r\n  const names = operations.map(op => op.name?.value);\r\n  if (prevSelectedOperationName && names.includes(prevSelectedOperationName)) {\r\n    return prevSelectedOperationName;\r\n  }\r\n\r\n  // If a previous selection was the Nth operation, use the same Nth.\r\n  if (prevSelectedOperationName && prevOperations) {\r\n    const prevNames = prevOperations.map(op => op.name?.value);\r\n    const prevIndex = prevNames.indexOf(prevSelectedOperationName);\r\n    if (prevIndex !== -1 && prevIndex < names.length) {\r\n      return names[prevIndex];\r\n    }\r\n  }\r\n\r\n  // Use the first operation.\r\n  return names[0];\r\n}\r\n", "/**\r\n * This describes the attributes and methods that a store has to support in\r\n * order to be used with GraphiQL. It closely resembles the `localStorage`\r\n * API as it is the default storage used in GraphiQL.\r\n */\r\nexport type Storage = {\r\n  /**\r\n   * Retrieve an item from the store by its key.\r\n   * @param key The key of the item to retrieve.\r\n   * @returns {?string} The stored value for the given key if it exists, `null`\r\n   * otherwise.\r\n   */\r\n  getItem(key: string): string | null;\r\n  /**\r\n   * Add a value to the store for a given key. If there already exists a value\r\n   * for the given key, this method will override the value.\r\n   * @param key The key to store the value for.\r\n   * @param value The value to store.\r\n   */\r\n  setItem(key: string, value: string): void;\r\n  /**\r\n   * Remove the value for a given key from the store. If there is no value for\r\n   * the given key this method does nothing.\r\n   * @param key The key to remove the value from the store.\r\n   */\r\n  removeItem(key: string): void;\r\n  /**\r\n   * Remove all items from the store.\r\n   */\r\n  clear(): void;\r\n  /**\r\n   * The number of items that are currently stored.\r\n   */\r\n  length: number;\r\n};\r\n\r\nfunction isQuotaError(storage: Storage, e: unknown) {\r\n  return (\r\n    e instanceof DOMException &&\r\n    // everything except Firefox\r\n    (e.code === 22 ||\r\n      // Firefox\r\n      e.code === 1014 ||\r\n      // test name field too, because code might not be present\r\n      // everything except Firefox\r\n      e.name === 'QuotaExceededError' ||\r\n      // Firefox\r\n      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\r\n    // acknowledge QuotaExceededError only if there's something already stored\r\n    storage.length !== 0\r\n  );\r\n}\r\n\r\nexport class StorageAPI {\r\n  storage: Storage | null;\r\n\r\n  constructor(storage?: Storage | null) {\r\n    if (storage) {\r\n      this.storage = storage;\r\n    } else if (storage === null) {\r\n      // Passing `null` creates a noop storage\r\n      this.storage = null;\r\n    } else if (typeof window === 'undefined') {\r\n      this.storage = null;\r\n    } else {\r\n      this.storage = {\r\n        getItem: window.localStorage.getItem.bind(window.localStorage),\r\n        setItem: window.localStorage.setItem.bind(window.localStorage),\r\n        removeItem: window.localStorage.removeItem.bind(window.localStorage),\r\n\r\n        get length() {\r\n          let keys = 0;\r\n          for (const key in window.localStorage) {\r\n            if (key.indexOf(`${STORAGE_NAMESPACE}:`) === 0) {\r\n              keys += 1;\r\n            }\r\n          }\r\n          return keys;\r\n        },\r\n\r\n        clear: () => {\r\n          // We only want to clear the namespaced items\r\n          for (const key in window.localStorage) {\r\n            if (key.indexOf(`${STORAGE_NAMESPACE}:`) === 0) {\r\n              window.localStorage.removeItem(key);\r\n            }\r\n          }\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  get(name: string): string | null {\r\n    if (!this.storage) {\r\n      return null;\r\n    }\r\n\r\n    const key = `${STORAGE_NAMESPACE}:${name}`;\r\n    const value = this.storage.getItem(key);\r\n    // Clean up any inadvertently saved null/undefined values.\r\n    if (value === 'null' || value === 'undefined') {\r\n      this.storage.removeItem(key);\r\n      return null;\r\n    }\r\n\r\n    return value || null;\r\n  }\r\n\r\n  set(\r\n    name: string,\r\n    value: string,\r\n  ): { isQuotaError: boolean; error: Error | null } {\r\n    let quotaError = false;\r\n    let error: Error | null = null;\r\n\r\n    if (this.storage) {\r\n      const key = `${STORAGE_NAMESPACE}:${name}`;\r\n      if (value) {\r\n        try {\r\n          this.storage.setItem(key, value);\r\n        } catch (e) {\r\n          error = e instanceof Error ? e : new Error(`${e}`);\r\n          quotaError = isQuotaError(this.storage, e);\r\n        }\r\n      } else {\r\n        // Clean up by removing the item if there's no value to set\r\n        this.storage.removeItem(key);\r\n      }\r\n    }\r\n\r\n    return { isQuotaError: quotaError, error };\r\n  }\r\n\r\n  clear() {\r\n    if (this.storage) {\r\n      this.storage.clear();\r\n    }\r\n  }\r\n}\r\n\r\nconst STORAGE_NAMESPACE = 'graphiql';\r\n", "import { StorageAPI } from './base';\r\n\r\nexport type QueryStoreItem = {\r\n  query?: string;\r\n  variables?: string;\r\n  headers?: string;\r\n  operationName?: string;\r\n  label?: string;\r\n  favorite?: boolean;\r\n};\r\n\r\nexport class QueryStore {\r\n  items: Array<QueryStoreItem>;\r\n\r\n  constructor(\r\n    private key: string,\r\n    private storage: StorageAPI,\r\n    private maxSize: number | null = null,\r\n  ) {\r\n    this.items = this.fetchAll();\r\n  }\r\n\r\n  get length() {\r\n    return this.items.length;\r\n  }\r\n\r\n  contains(item: QueryStoreItem) {\r\n    return this.items.some(\r\n      x =>\r\n        x.query === item.query &&\r\n        x.variables === item.variables &&\r\n        x.headers === item.headers &&\r\n        x.operationName === item.operationName,\r\n    );\r\n  }\r\n\r\n  edit(item: QueryStoreItem) {\r\n    const itemIndex = this.items.findIndex(\r\n      x =>\r\n        x.query === item.query &&\r\n        x.variables === item.variables &&\r\n        x.headers === item.headers &&\r\n        x.operationName === item.operationName,\r\n    );\r\n    if (itemIndex !== -1) {\r\n      this.items.splice(itemIndex, 1, item);\r\n      this.save();\r\n    }\r\n  }\r\n\r\n  delete(item: QueryStoreItem) {\r\n    const itemIndex = this.items.findIndex(\r\n      x =>\r\n        x.query === item.query &&\r\n        x.variables === item.variables &&\r\n        x.headers === item.headers &&\r\n        x.operationName === item.operationName,\r\n    );\r\n    if (itemIndex !== -1) {\r\n      this.items.splice(itemIndex, 1);\r\n      this.save();\r\n    }\r\n  }\r\n\r\n  fetchRecent() {\r\n    return this.items.at(-1);\r\n  }\r\n\r\n  fetchAll() {\r\n    const raw = this.storage.get(this.key);\r\n    if (raw) {\r\n      return JSON.parse(raw)[this.key] as Array<QueryStoreItem>;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  push(item: QueryStoreItem) {\r\n    const items = [...this.items, item];\r\n\r\n    if (this.maxSize && items.length > this.maxSize) {\r\n      items.shift();\r\n    }\r\n\r\n    for (let attempts = 0; attempts < 5; attempts++) {\r\n      const response = this.storage.set(\r\n        this.key,\r\n        JSON.stringify({ [this.key]: items }),\r\n      );\r\n      if (!response?.error) {\r\n        this.items = items;\r\n      } else if (response.isQuotaError && this.maxSize) {\r\n        // Only try to delete last items on LRU stores\r\n        items.shift();\r\n      } else {\r\n        return; // We don't know what happened in this case, so just bailing out\r\n      }\r\n    }\r\n  }\r\n\r\n  save() {\r\n    this.storage.set(this.key, JSON.stringify({ [this.key]: this.items }));\r\n  }\r\n}\r\n", "import { parse } from 'graphql';\r\n\r\nimport { StorageAPI } from './base';\r\nimport { QueryStore, QueryStoreItem } from './query';\r\n\r\nconst MAX_QUERY_SIZE = 100000;\r\n\r\nexport class HistoryStore {\r\n  queries: Array<QueryStoreItem>;\r\n  history: QueryStore;\r\n  favorite: QueryStore;\r\n\r\n  constructor(private storage: StorageAPI, private maxHistoryLength: number) {\r\n    this.history = new QueryStore(\r\n      'queries',\r\n      this.storage,\r\n      this.maxHistoryLength,\r\n    );\r\n    // favorites are not automatically deleted, so there's no need for a max length\r\n    this.favorite = new QueryStore('favorites', this.storage, null);\r\n\r\n    this.queries = [...this.history.fetchAll(), ...this.favorite.fetchAll()];\r\n  }\r\n\r\n  private shouldSaveQuery(\r\n    query?: string,\r\n    variables?: string,\r\n    headers?: string,\r\n    lastQuerySaved?: QueryStoreItem,\r\n  ) {\r\n    if (!query) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      parse(query);\r\n    } catch {\r\n      return false;\r\n    }\r\n\r\n    // Don't try to save giant queries\r\n    if (query.length > MAX_QUERY_SIZE) {\r\n      return false;\r\n    }\r\n    if (!lastQuerySaved) {\r\n      return true;\r\n    }\r\n    if (JSON.stringify(query) === JSON.stringify(lastQuerySaved.query)) {\r\n      if (\r\n        JSON.stringify(variables) === JSON.stringify(lastQuerySaved.variables)\r\n      ) {\r\n        if (\r\n          JSON.stringify(headers) === JSON.stringify(lastQuerySaved.headers)\r\n        ) {\r\n          return false;\r\n        }\r\n        if (headers && !lastQuerySaved.headers) {\r\n          return false;\r\n        }\r\n      }\r\n      if (variables && !lastQuerySaved.variables) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  updateHistory = (\r\n    query?: string,\r\n    variables?: string,\r\n    headers?: string,\r\n    operationName?: string,\r\n  ) => {\r\n    if (\r\n      this.shouldSaveQuery(\r\n        query,\r\n        variables,\r\n        headers,\r\n        this.history.fetchRecent(),\r\n      )\r\n    ) {\r\n      this.history.push({\r\n        query,\r\n        variables,\r\n        headers,\r\n        operationName,\r\n      });\r\n      const historyQueries = this.history.items;\r\n      const favoriteQueries = this.favorite.items;\r\n      this.queries = historyQueries.concat(favoriteQueries);\r\n    }\r\n  };\r\n\r\n  toggleFavorite(\r\n    query?: string,\r\n    variables?: string,\r\n    headers?: string,\r\n    operationName?: string,\r\n    label?: string,\r\n    favorite?: boolean,\r\n  ) {\r\n    const item: QueryStoreItem = {\r\n      query,\r\n      variables,\r\n      headers,\r\n      operationName,\r\n      label,\r\n    };\r\n    if (!this.favorite.contains(item)) {\r\n      item.favorite = true;\r\n      this.favorite.push(item);\r\n    } else if (favorite) {\r\n      item.favorite = false;\r\n      this.favorite.delete(item);\r\n    }\r\n    this.queries = [...this.history.items, ...this.favorite.items];\r\n  }\r\n\r\n  editLabel(\r\n    query?: string,\r\n    variables?: string,\r\n    headers?: string,\r\n    operationName?: string,\r\n    label?: string,\r\n    favorite?: boolean,\r\n  ) {\r\n    const item = {\r\n      query,\r\n      variables,\r\n      headers,\r\n      operationName,\r\n      label,\r\n    };\r\n    if (favorite) {\r\n      this.favorite.edit({ ...item, favorite });\r\n    } else {\r\n      this.history.edit(item);\r\n    }\r\n    this.queries = [...this.history.items, ...this.favorite.items];\r\n  }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;AAAA;AAAA;AAAA,UAAM,IAAI,MAAM,kFAAkF;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACO5F,SAAU,UAAa,OAAuB;AAClD,SACE,OAAO,UAAU,YACjB,UAAU,QACV,OAAO,MAAM,SAAS;AAE1B;AAGA,SAAS,oBAAuB,YAAyB;AACvD,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACrC,UAAM,eAAe,WAAW,UAAU;MACxC,MAAM,OAAI;AACR,gBAAQ,CAAC;AACT,qBAAa,YAAW;MAC1B;MACA,OAAO;MACP,UAAU,MAAK;AACb,eAAO,IAAI,MAAM,mBAAmB,CAAC;MACvC;KACD;EACH,CAAC;AACH;AAGM,SAAU,aAAgB,OAAU;AACxC,SACE,OAAO,UAAU,YACjB,UAAU,QACV,eAAe,SACf,OAAO,MAAM,cAAc;AAE/B;AAEM,SAAU,gBACd,OAAc;AAEd,SACE,OAAO,UAAU,YACjB,UAAU,SAGR,MAAc,OAAO,WAAW,MAAM,oBACtC,OAAO,iBAAiB;AAE9B;AAEA,SAAe,uBACb,OAAkD;;;AAKlD,UAAM,kBAAiB,MACrB,YAAY,QAAQ,QAAQ,MAAM,OAAO,aAAa,EAAC,GACvD,YAAM,QAAA,OAAA,SAAA,SAAA,GAAE,KAAK,KAAK;AACpB,UAAM,gBACJ,UAAU,QAAQ,QAAQ,MAAM,OAAO,aAAa,EAAC,GACrD,KAAK,KAAK,KAAK;AAEjB,UAAM,SAAS,MAAM,aAAY;AAEjC,UAAK,mBAAc,QAAd,mBAAc,SAAA,SAAd,eAAc;AACnB,WAAO,OAAO;;;AAGV,SAAgB,uBACpB,eAAgC;;AAEhC,UAAM,SAAS,MAAM;AACrB,QAAI,gBAAgB,MAAM,GAAG;AAC3B,aAAO,uBAAuB,MAAM;;AAEtC,QAAI,aAAa,MAAM,GAAG;AACxB,aAAO,oBAAoB,MAAM;;AAEnC,WAAO;EACT,CAAC;;;;ACpFD,eAAe,EAAEA,IAAE,GAAE;AAAC,MAAI,IAAEA,GAAE,QAAQ,cAAc;AAAE,MAAG,CAAC,KAAG,CAAC,CAAC,EAAE,QAAQ,YAAY;AAAE,WAAOA;AAAE,MAAI,IAAE,EAAE,QAAQ,WAAW,GAAE,IAAE;AAAI,MAAG,CAAC,GAAE;AAAC,QAAIA,KAAE,IAAE,GAAEC,KAAE,EAAE,QAAQ,KAAID,EAAC;AAAE,QAAE,EAAE,MAAMA,IAAEC,KAAE,KAAGA,KAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,MAAK,EAAE;AAAA,EAAC;AAAC,SAAO,iBAAgBD,IAAEC,IAAEC,IAAE;AAAC,QAAIC,IAAEC,IAAE,GAAE,IAAE,CAACF,MAAG,CAACA,GAAE,UAAS,IAAE,OAAO,WAAWD,EAAC,GAAE,IAAE,OAAO,MAAM,CAAC,GAAE,IAAE,CAAC;AAAE;AAAE,qBAAcC,MAAKF,IAAE;AAAC,QAAAG,KAAE,EAAE,YAAW,IAAE,OAAO,OAAO,CAAC,GAAED,EAAC,CAAC;AAAE,YAAIF,KAAEE,GAAE,QAAQD,EAAC;AAAE,aAAI,CAACD,KAAEG,MAAGH,KAAEG,KAAE,EAAE,QAAQF,EAAC,GAAE,IAAE,CAAC,GAAE,CAACE,MAAG;AAAC,cAAIH,KAAE,EAAE,SAAS,GAAEG,EAAC,GAAED,KAAE,EAAE,SAASC,KAAE,CAAC;AAAE,cAAGC,IAAE;AAAC,gBAAIH,KAAED,GAAE,QAAQ,UAAU,IAAE,GAAEG,KAAEH,GAAE,YAAY,QAAOC,EAAC,GAAEG,KAAE,OAAGC,KAAEL,GAAE,SAASC,IAAEE,KAAE,KAAG,SAAOA,EAAC,GAAEG,KAAE,OAAON,GAAE,SAAS,GAAEC,EAAC,CAAC,EAAE,KAAK,EAAE,MAAM,MAAM,GAAE,IAAE,CAAC,GAAE,IAAEK,GAAE;AAAO,mBAAK,IAAEA,GAAE,EAAE,CAAC,GAAE,IAAE,EAAE,MAAM,IAAI,GAAE,EAAE,EAAE,MAAM,EAAE,YAAY,CAAC,IAAE,EAAE,KAAK,IAAI;AAAE;AAAC,gBAAG,IAAE,EAAE,cAAc,GAAE,KAAG,CAAC,EAAE,QAAQ,kBAAkB;AAAE,kBAAG;AAAC,gBAAAD,KAAE,KAAK,MAAM,OAAOA,EAAC,CAAC,GAAED,KAAE;AAAA,cAAE,SAAOJ,IAAE;AAAA,cAAC;AAAC,gBAAG,IAAE,EAAC,SAAQ,GAAE,MAAKK,IAAE,MAAKD,GAAC,GAAE,IAAE,MAAM,IAAE,EAAE,KAAK,CAAC,GAAE,OAAKF,GAAE,CAAC,KAAG,OAAKA,GAAE,CAAC;AAAE,oBAAM;AAAA,UAAC;AAAM,YAAAD,KAAE,SAAOA,IAAEG,KAAE,KAAG;AAAE,cAAEF,IAAEC,KAAE,EAAE,QAAQF,EAAC;AAAA,QAAC;AAAC,UAAE,WAAS,MAAM;AAAA,MAAE;AAAC,MAAE,WAAS,MAAM;AAAA,EAAE,EAAED,IAAE,KAAK,CAAC,IAAG,CAAC;AAAC;;;ACO39B,SAAS,aAAa,QAAQ,UAAU,SAAS;AAC7C,QAAM,SAAU,gBAAgB,mBAAmB;AAC/C,WAAO;AAAA,EACX,EAAG;AACH,QAAM,iBAAiB,OAAO,OAAO,KAAK,MAAM;AAChD,MAAI,UAAU;AACV,WAAO,SAAS,IAAI,SAAS;AACzB,eAAS;AACT,aAAO,eAAe,GAAG,IAAI;AAAA,IACjC;AAAA,EACJ;AACA,MAAI,SAAS;AACT,UAAM,gBAAgB,OAAO,MAAM,KAAK,MAAM;AAC9C,WAAO,QAAQ,CAAC,QAAQ;AACpB,cAAQ,GAAG;AACX,aAAO,cAAc,GAAG;AAAA,IAC5B;AAAA,EACJ;AACA,SAAO;AACX;AAEA,SAAS,iBAAiB;AACtB,QAAM,IAAI,CAAC;AACX,IAAE,UAAU,IAAI,QAAQ,CAAC,SAAS,WAAW;AACzC,MAAE,UAAU;AACZ,MAAE,SAAS;AAAA,EACf,CAAC;AACD,SAAO;AACX;AAQA,SAAS,oCAAoC;AACzC,MAAI,QAAQ;AAAA,IACR,MAAM;AAAA;AAAA,EACV;AACA,MAAI,OAAO,eAAe;AAC1B,QAAM,SAAS,CAAC;AAChB,WAAS,UAAU,OAAO;AACtB,QAAI,MAAM,SAAS,WAAyB;AACxC;AAAA,IACJ;AACA,WAAO,KAAK,KAAK;AACjB,SAAK,QAAQ;AACb,WAAO,eAAe;AAAA,EAC1B;AACA,QAAM,SAAU,gBAAgB,gCAAgC;AAC5D,WAAO,MAAM;AACT,UAAI,OAAO,SAAS,GAAG;AAEnB,cAAM,OAAO,MAAM;AAAA,MACvB,OACK;AACD,YAAI,MAAM,SAAS,SAAqB;AACpC,gBAAM,MAAM;AAAA,QAChB;AACA,YAAI,MAAM,SAAS,YAA2B;AAC1C;AAAA,QACJ;AACA,cAAM,KAAK;AAAA,MACf;AAAA,IACJ;AAAA,EACJ,EAAG;AACH,QAAM,SAAS,aAAa,QAAQ,MAAM;AACtC,QAAI,MAAM,SAAS,WAAyB;AACxC;AAAA,IACJ;AACA,YAAQ;AAAA,MACJ,MAAM;AAAA;AAAA,IACV;AACA,SAAK,QAAQ;AAAA,EACjB,GAAG,CAAC,UAAU;AACV,QAAI,MAAM,SAAS,WAAyB;AACxC;AAAA,IACJ;AACA,YAAQ;AAAA,MACJ,MAAM;AAAA,MACN;AAAA,IACJ;AACA,SAAK,QAAQ;AAAA,EACjB,CAAC;AACD,SAAO;AAAA,IACH;AAAA,IACA,uBAAuB;AAAA,EAC3B;AACJ;AAEA,IAAM,oCAAoC,CAAC,SAAS;AAChD,QAAM,EAAE,WAAW,sBAAsB,IAAI,kCAAkC;AAC/E,QAAM,UAAU,KAAK;AAAA,IACjB,MAAM,CAAC,UAAU;AACb,gBAAU,KAAK;AAAA,IACnB;AAAA,IACA,UAAU,MAAM;AAEZ,4BAAsB,OAAO;AAAA,IACjC;AAAA,IACA,OAAO,CAAC,QAAQ;AAEZ,4BAAsB,MAAM,GAAG;AAAA,IACnC;AAAA,EACJ,CAAC;AAED,QAAM,iBAAiB,sBAAsB;AAC7C,MAAI,cAAc;AAClB,wBAAsB,SAAS,MAAM;AACjC,QAAI,gBAAgB,QAAW;AAC3B,cAAQ;AACR,oBAAc,eAAe;AAAA,IACjC;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX;AAqBA,SAASO,iBAAgB,OAAO;AAC5B,SAAQ,OAAO,UAAU,YACrB,UAAU;AAAA;AAAA;AAAA;AAAA,GAKT,MAAM,OAAO,WAAW,MAAM,oBAC1B,OAAO,iBAAiB,OAAO,iBAAiB;AAC7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrIA,IAAM,eAAe,CAAC,QAAyC;AAC7D,SAAO,OAAO,QAAQ,YAAY,QAAQ,QAAQ,UAAU;AAC9D;AASO,IAAM,yBAAyB,CACpC,UACA,SACW;AACX,MAAI,iBAAiB;AACrB,QAAM,UAAU;IACd,oBAAoB,MAAI;;AACtB,UAAI,WAAS,KAAA,KAAK,UAAI,QAAA,OAAA,SAAA,SAAA,GAAE,UAAS,KAAK,cAAc,gBAAgB;AAClE,yBAAiB;;IAErB;GACD;AACD,SAAO;AACT;AAUO,IAAM,sBACX,CAAC,SAA+B,cAChC,CAAO,eAA8B,gBAA6BC,WAAA,QAAA,QAAA,QAAA,aAAA;AAChE,QAAM,OAAO,MAAM,UAAU,QAAQ,KAAK;IACxC,QAAQ;IACR,MAAM,KAAK,UAAU,aAAa;IAClC,SAAO,OAAA,OAAA,OAAA,OAAA,EACL,gBAAgB,mBAAkB,GAC/B,QAAQ,OAAO,GACf,gBAAW,QAAX,gBAAW,SAAA,SAAX,YAAa,OAAO;GAE1B;AACD,SAAO,KAAK,KAAI;AAClB,CAAC;AAEI,IAAM,iCAAiC,CAC5C,KACA,qBACE;AACF,MAAI;AACJ,MAAI;AACF,UAAM,EAAE,aAAY,IAAK;AAKzB,eAAW,aAAa;MACtB;MACA;KACD;AACD,WAAO,kCAAkC,QAAQ;WAC1C,KAAK;AACZ,QAAI,aAAa,GAAG,KAAK,IAAI,SAAS,oBAAoB;AACxD,YAAM,IAAI,MACR,iGAAiG;;AAIrG,YAAQ,MAAM,uCAAuC,GAAG,IAAI,GAAG;;AAEnE;AAQO,IAAM,oCACX,CAAC,aAAqB,CAAC,kBACrB,kCAAmD,UACjD,SAAS,UAAU,eAAa,OAAA,OAAA,OAAA,OAAA,CAAA,GAC3B,IAAI,GAAA,EACP,OAAO,SAAM;AACX,MAAI,eAAe,YAAY;AAC7B,SAAK,MACH,IAAI,MACF,4BAA4B,IAAI,IAAI,IAClC,IAAI,UAAU,EAChB,GAAG,KAAI,CAAE,CACV;SAEE;AACL,SAAK,MAAM,GAAG;;AAElB,EAAC,CAAA,CAAA,CACD;AAUD,IAAM,gCACX,CAAC,mBACD,CAAC,kBAAgC;AAC/B,QAAM,aAAa,eAAe,QAAQ,aAAa;AACvD,SAAO,kCAEL,UAAQ,WAAW,UAAU,IAAI,EAAE,WAAW;AAElD;AAQK,IAAM,yBAAyB,CACpC,SACA,cAEA,SAAiB,eAA8B,aAAyB;;;AACtE,UAAM,WAAW,MAAA,QAAM,UAAU,QAAQ,KAAK;MAC5C,QAAQ;MACR,MAAM,KAAK,UAAU,aAAa;MAClC,SAAO,OAAA,OAAA,OAAA,OAAA,EACL,gBAAgB,oBAChB,QAAQ,oCAAmC,GACxC,QAAQ,OAAO,GAGf,gBAAW,QAAX,gBAAW,SAAA,SAAX,YAAa,OAAO;KAE1B,EAAE,KAAK,OACN,EAA6D,GAAG;MAC9D,UAAU;KACX,CAAC,CACH;AAGD,QAAI,CAACC,iBAAgB,QAAQ,GAAG;AAC9B,aAAA,MAAA,QAAO,MAAA,MAAA,QAAM,SAAS,KAAI,CAAE,CAAA;;;AAG9B,eAA0B,aAAA,cAAA,QAAQ,GAAA,cAAA,eAAA,MAAA,QAAA,WAAA,KAAA,CAAA,GAAA,CAAA,aAAA,QAAA;AAAvB,cAAM,QAAK,aAAA;AACpB,YAAI,MAAM,KAAK,UAAQ,CAAC,KAAK,IAAI,GAAG;AAClC,gBAAM,UAAU,MAAM,IACpB,UAAQ;EAAc,KAAK,OAAO;;;EAAe,KAAK,IAAI,EAAE;AAE9D,gBAAM,IAAI,MACR;EAAuD,OAAO,EAAE;;AAGpE,cAAA,MAAA,QAAM,MAAM,IAAI,UAAQ,KAAK,IAAI,CAAC;;;;;;;;;;;;;EAEtC,CAAC;;AAOI,IAAM,eAAe,CAC1B,SACA,gBACE;AACF,MAAI,QAAQ,UAAU;AACpB,WAAO,kCAAkC,QAAQ,QAAQ;;AAE3D,MAAI,QAAQ,iBAAiB;AAC3B,WAAO,+BAA+B,QAAQ,iBAAe,OAAA,OAAA,OAAA,OAAA,CAAA,GACxD,QAAQ,kBAAkB,GAC1B,gBAAW,QAAX,gBAAW,SAAA,SAAX,YAAa,OAAO,CAAA;;AAG3B,QAAM,yBAAyB,QAAQ,gBAAgB,QAAQ;AAC/D,MAAI,wBAAwB;AAC1B,WAAO,8BAA8B,sBAAsB;;AAE/D;;;AChMM,SAAU,sBAAsB,SAA6B;AACjE,MAAI;AACJ,MAAI,OAAO,WAAW,eAAe,OAAO,OAAO;AACjD,gBAAY,OAAO;;AAErB,OACE,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS,+BAA8B,QACvC,QAAQ,8BAA8B,OACtC;AACA,YAAQ,4BAA4B;;AAEtC,MAAI,QAAQ,OAAO;AACjB,gBAAY,QAAQ;;AAEtB,MAAI,CAAC,WAAW;AACd,UAAM,IAAI,MAAM,2CAA2C;;AAG7D,QAAM,gBAAgB,oBAAoB,SAAS,SAAS;AAE5D,QAAM,cAAc,QAAQ,4BACxB,uBAAuB,SAAS,SAAS,IACzC;AAEJ,SAAO,CAAC,eAAe,gBAAe;AACpC,QAAI,cAAc,kBAAkB,sBAAsB;AACxD,cAAQ,QAAQ,iBAAiB,eAC/B,eACA,WAAW;;AAGf,UAAM,kBAAiB,gBAAW,QAAX,gBAAW,SAAA,SAAX,YAAa,eAChC,uBACE,YAAY,aACZ,cAAc,iBAAiB,MAAS,IAE1C;AACJ,QAAI,gBAAgB;AAClB,YAAM,YAAY,aAAa,SAAS,WAAW;AAEnD,UAAI,CAAC,WAAW;AACd,cAAM,IAAI,MACR,2FACE,QAAQ,kBACJ,gBAAgB,QAAQ,eAAe,YACvC,wEACN,EAAE;;AAGN,aAAO,UAAU,aAAa;;AAEhC,WAAO,YAAY,eAAe,WAAW;EAC/C;AACF;;;ACtEA,SAAS,UAAU,KAAY;AAC7B,SAAO,KAAK,UAAU,KAAK,MAAM,CAAC;AACpC;AAEA,SAAS,kBAAkB,OAAY;AACrC,SAAA,OAAA,OAAA,OAAA,OAAA,CAAA,GACK,KAAK,GAAA,EAER,SAAS,MAAM,SACf,OAAO,MAAM,MAAK,CAAA;AAEtB;AAEA,SAAS,kBAAkB,OAAc;AACvC,MAAI,iBAAiB,OAAO;AAC1B,WAAO,kBAAkB,KAAK;;AAEhC,SAAO;AACT;AAEM,SAAU,YAAY,OAAc;AACxC,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,WAAO,UAAU;MACf,QAAQ,MAAM,IAAI,CAAAC,OAAK,kBAAkBA,EAAC,CAAC;KAC5C;;AAEH,SAAO,UAAU,EAAE,QAAQ,CAAC,kBAAkB,KAAK,CAAC,EAAC,CAAE;AACzD;AAEM,SAAU,aAAa,QAAW;AACtC,SAAO,UAAU,MAAM;AACzB;;;ACCM,SAAU,UACd,QACA,WACA,sBAA6C;AAE7C,QAAM,aAA0B,CAAA;AAEhC,MAAI,CAAC,UAAU,CAAC,WAAW;AACzB,WAAO,EAAE,YAAY,QAAQ,UAAS;;AAGxC,MAAI;AACJ,MAAI;AACF,UAAM,MAAM,SAAS;WACrB,IAAM;AACN,WAAO,EAAE,YAAY,QAAQ,UAAS;;AAGxC,QAAM,cAAc,wBAAwB;AAC5C,QAAM,WAAW,IAAI,SAAS,MAAM;AACpC,QAAM,KAAK;IACT,MAAM,MAAI;AACR,eAAS,MAAM,IAAI;IACrB;IACA,MAAM,MAAI;AACR,eAAS,MAAM,IAAI;AACnB,UAAI,KAAK,SAAS,WAAW,CAAC,KAAK,cAAc;AAC/C,cAAM,YAAY,SAAS,QAAO;AAClC,cAAM,eAAe,kBACnB,YAAY,SAAS,GACrB,WAAW;AAEb,YAAI,gBAAgB,KAAK,KAAK;AAC5B,gBAAM,SAAS,eAAe,WAAW,KAAK,IAAI,KAAK;AACvD,qBAAW,KAAK;YACd,OAAO,KAAK,IAAI;YAChB,QAAQ,MAAM,MAAM,YAAY,EAAE,WAAW,MAAM,OAAO,MAAM;WACjE;;;IAGP;GACD;AAGD,SAAO;IACL;IACA,QAAQ,eAAe,WAAW,UAAU;;AAEhD;AAKA,SAAS,4BAA4B,MAAiB;AAGpD,MAAI,EAAE,eAAe,OAAO;AAC1B,WAAO,CAAA;;AAGT,QAAM,SAAS,KAAK,UAAS;AAG7B,MAAI,OAAO,IAAI;AACb,WAAO,CAAC,IAAI;;AAId,MAAI,OAAO,OAAO;AAChB,WAAO,CAAC,OAAO;;AAIjB,MAAI,OAAO,MAAM;AACf,WAAO,CAAC,MAAM;;AAIhB,QAAM,iBAAgC,CAAA;AACtC,aAAW,aAAa,OAAO,KAAK,MAAM,GAAG;AAC3C,QAAI,WAAW,OAAO,SAAS,EAAE,IAAI,GAAG;AACtC,qBAAe,KAAK,SAAS;;;AAGjC,SAAO;AACT;AAIA,SAAS,kBACP,MACA,sBAA4C;AAG5C,QAAM,YAAY,aAAa,IAAI;AAGnC,MAAI,CAAC,QAAQ,WAAW,IAAI,GAAG;AAC7B;;AAIF,QAAM,aAAa,qBAAqB,SAAS;AAGjD,MACE,CAAC,MAAM,QAAQ,UAAU,KACzB,WAAW,WAAW,KACtB,EAAE,eAAe,YACjB;AACA;;AAIF,SAAO;IACL,MAAM,KAAK;IACX,YAAY,WAAW,IAAI,eAAY;AACrC,YAAM,WAAW,UAAU,UAAS,EAAG,SAAS;AAChD,YAAM,YAAY,WAAW,SAAS,OAAO;AAC7C,aAAO;QACL,MAAM,KAAK;QACX,MAAM;UACJ,MAAM,KAAK;UACX,OAAO;;QAIT,cAAc,kBACZ,WACA,oBAAoB;;IAG1B,CAAC;;AAEL;AAIA,SAAS,eAAe,SAAiB,YAAuB;AAC9D,MAAI,WAAW,WAAW,GAAG;AAC3B,WAAO;;AAET,MAAI,SAAS;AACb,MAAI,YAAY;AAChB,aAAW,EAAE,OAAO,OAAM,KAAM,YAAY;AAC1C,cAAU,QAAQ,MAAM,WAAW,KAAK,IAAI;AAC5C,gBAAY;;AAEd,YAAU,QAAQ,MAAM,SAAS;AACjC,SAAO;AACT;AAIA,SAAS,eAAe,KAAa,OAAa;AAChD,MAAI,cAAc;AAClB,MAAI,YAAY;AAChB,SAAO,aAAa;AAClB,UAAM,IAAI,IAAI,WAAW,cAAc,CAAC;AAExC,QAAI,MAAM,MAAM,MAAM,MAAM,MAAM,QAAU,MAAM,MAAQ;AACxD;;AAEF;AAEA,QAAI,MAAM,KAAK,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,KAAK;AAC5D,kBAAY;;;AAGhB,SAAO,IAAI,MAAM,aAAa,SAAS;AACzC;AAEA,SAAS,YACP,WAA+C;AAE/C,MAAI,WAAW;AACb,WAAO;;AAEX;;;ACnMA,SAAS,SACP,OACA,UAAgC;;AAEhC,QAAM,cAAc,oBAAI,IAAG;AAC3B,QAAM,SAA0B,CAAA;AAChC,aAAW,QAAQ,OAAO;AACxB,QAAI,KAAK,SAAS,SAAS;AACzB,YAAM,cAAc,SAAS,IAAI;AACjC,YAAM,WAAW,YAAY,IAAI,WAAW;AAC5C,WAAI,KAAA,KAAK,gBAAU,QAAA,OAAA,SAAA,SAAA,GAAE,QAAQ;AAE3B,cAAM,YAAS,OAAA,OAAA,CAAA,GAAQ,IAAI;AAC3B,eAAO,KAAK,SAAS;kBACZ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU,iBAAgB,KAAK,cAAc;AAEtD,iBAAS,aAAa,aAAa;UACjC,GAAG,SAAS,aAAa;UACzB,GAAG,KAAK,aAAa;;iBAEd,CAAC,UAAU;AACpB,cAAM,YAAS,OAAA,OAAA,CAAA,GAAQ,IAAI;AAC3B,oBAAY,IAAI,aAAa,SAAS;AACtC,eAAO,KAAK,SAAS;;WAElB;AACL,aAAO,KAAK,IAAI;;;AAGpB,SAAO;AACT;AAEA,SAAS,8BACP,qBAGA,YACA,kBAA2C;;AAE3C,QAAM,uBAAuB,mBACzB,aAAa,gBAAgB,EAAE,OAC/B;AACJ,QAAM,mBAAmB,CAAA;AACzB,QAAM,cAAwB,CAAA;AAC9B,WAAS,aAAa,YAAY;AAChC,QAAI,UAAU,SAAS,kBAAkB;AACvC,YAAM,eAAe,UAAU,KAAK;AACpC,UAAI,CAAC,UAAU,cAAc,UAAU,WAAW,WAAW,GAAG;AAC9D,YAAI,YAAY,SAAS,YAAY,GAAG;AAEtC;eACK;AACL,sBAAY,KAAK,YAAY;;;AAGjC,YAAM,qBAAqB,oBAAoB,UAAU,KAAK,KAAK;AACnE,UAAI,oBAAoB;AACtB,cAAM,EAAE,eAAe,YAAY,aAAY,IAAK;AACpD,oBAAY;UACV,MAAM,KAAK;UACX;UACA;UACA;;;;AAIN,QACE,UAAU,SAAS,KAAK,oBAEvB,CAAC,UAAU,gBAAc,KAAA,UAAU,gBAAU,QAAA,OAAA,SAAA,SAAA,GAAE,YAAW,IAC3D;AACA,YAAM,mBAAmB,UAAU,gBAC/B,UAAU,cAAc,KAAK,QAC7B;AACJ,UAAI,CAAC,oBAAoB,qBAAqB,sBAAsB;AAClE,yBAAiB,KACf,GAAG,8BACD,qBACA,UAAU,aAAa,YACvB,gBAAgB,CACjB;AAEH;;;AAGJ,qBAAiB,KAAK,SAAS;;AAEjC,SAAO;AACT;AAKM,SAAU,SACd,aACA,QAA6B;AAI7B,QAAM,WAAW,SAAS,IAAI,SAAS,MAAM,IAAI;AAEjD,QAAM,sBAEF,uBAAO,OAAO,IAAI;AAEtB,aAAW,cAAc,YAAY,aAAa;AAChD,QAAI,WAAW,SAAS,KAAK,qBAAqB;AAChD,0BAAoB,WAAW,KAAK,KAAK,IAAI;;;AAIjD,QAAM,WAAuB;IAC3B,aAAa,MAAS;AACpB,YAAM,mBAAmB,WAAW,SAAS,cAAa,IAAK;AAC/D,UAAI,EAAE,WAAU,IAAK;AAErB,mBAAa,8BACX,qBACA,YACA,gBAAgB;AAGlB,mBAAa,SAAS,YAAY,eAChC,UAAU,QAAQ,UAAU,MAAM,QAAQ,UAAU,KAAK,KAAK;AAGhE,aAAA,OAAA,OAAA,OAAA,OAAA,CAAA,GACK,IAAI,GAAA,EACP,WAAU,CAAA;IAEd;IACA,qBAAkB;AAChB,aAAO;IACT;;AAGF,SAAO,MACL,aACA,WAAW,kBAAkB,UAAU,QAAQ,IAAI,QAAQ;AAE/D;;;ACrJM,SAAU,yBACd,gBACA,2BACA,YAAsC;AAGtC,MAAI,CAAC,cAAc,WAAW,SAAS,GAAG;AACxC;;AAIF,QAAM,QAAQ,WAAW,IAAI,QAAK;AAAA,QAAA;AAAC,YAAA,KAAA,GAAG,UAAI,QAAA,OAAA,SAAA,SAAA,GAAE;EAAK,CAAA;AACjD,MAAI,6BAA6B,MAAM,SAAS,yBAAyB,GAAG;AAC1E,WAAO;;AAIT,MAAI,6BAA6B,gBAAgB;AAC/C,UAAM,YAAY,eAAe,IAAI,QAAK;AAAA,UAAA;AAAC,cAAA,KAAA,GAAG,UAAI,QAAA,OAAA,SAAA,SAAA,GAAE;IAAK,CAAA;AACzD,UAAM,YAAY,UAAU,QAAQ,yBAAyB;AAC7D,QAAI,cAAc,MAAM,YAAY,MAAM,QAAQ;AAChD,aAAO,MAAM,SAAS;;;AAK1B,SAAO,MAAM,CAAC;AAChB;;;ACGA,SAAS,aAAa,SAAkBC,IAAU;AAChD,SACEA,cAAa,iBAEZA,GAAE,SAAS,MAEVA,GAAE,SAAS,QAGXA,GAAE,SAAS,wBAEXA,GAAE,SAAS,iCAEb,QAAQ,WAAW;AAEvB;AAEM,IAAO,aAAP,MAAiB;EAGrB,YAAY,SAAwB;AAClC,QAAI,SAAS;AACX,WAAK,UAAU;eACN,YAAY,MAAM;AAE3B,WAAK,UAAU;eACN,OAAO,WAAW,aAAa;AACxC,WAAK,UAAU;WACV;AACL,WAAK,UAAU;QACb,SAAS,OAAO,aAAa,QAAQ,KAAK,OAAO,YAAY;QAC7D,SAAS,OAAO,aAAa,QAAQ,KAAK,OAAO,YAAY;QAC7D,YAAY,OAAO,aAAa,WAAW,KAAK,OAAO,YAAY;QAEnE,IAAI,SAAM;AACR,cAAI,OAAO;AACX,qBAAW,OAAO,OAAO,cAAc;AACrC,gBAAI,IAAI,QAAQ,GAAG,iBAAiB,GAAG,MAAM,GAAG;AAC9C,sBAAQ;;;AAGZ,iBAAO;QACT;QAEA,OAAO,MAAK;AAEV,qBAAW,OAAO,OAAO,cAAc;AACrC,gBAAI,IAAI,QAAQ,GAAG,iBAAiB,GAAG,MAAM,GAAG;AAC9C,qBAAO,aAAa,WAAW,GAAG;;;QAGxC;;;EAGN;EAEA,IAAI,MAAY;AACd,QAAI,CAAC,KAAK,SAAS;AACjB,aAAO;;AAGT,UAAM,MAAM,GAAG,iBAAiB,IAAI,IAAI;AACxC,UAAM,QAAQ,KAAK,QAAQ,QAAQ,GAAG;AAEtC,QAAI,UAAU,UAAU,UAAU,aAAa;AAC7C,WAAK,QAAQ,WAAW,GAAG;AAC3B,aAAO;;AAGT,WAAO,SAAS;EAClB;EAEA,IACE,MACA,OAAa;AAEb,QAAI,aAAa;AACjB,QAAI,QAAsB;AAE1B,QAAI,KAAK,SAAS;AAChB,YAAM,MAAM,GAAG,iBAAiB,IAAI,IAAI;AACxC,UAAI,OAAO;AACT,YAAI;AACF,eAAK,QAAQ,QAAQ,KAAK,KAAK;iBACxBA,IAAG;AACV,kBAAQA,cAAa,QAAQA,KAAI,IAAI,MAAM,GAAGA,EAAC,EAAE;AACjD,uBAAa,aAAa,KAAK,SAASA,EAAC;;aAEtC;AAEL,aAAK,QAAQ,WAAW,GAAG;;;AAI/B,WAAO,EAAE,cAAc,YAAY,MAAK;EAC1C;EAEA,QAAK;AACH,QAAI,KAAK,SAAS;AAChB,WAAK,QAAQ,MAAK;;EAEtB;;AAGF,IAAM,oBAAoB;;;ACjIpB,IAAO,aAAP,MAAiB;EAGrB,YACU,KACA,SACA,UAAyB,MAAI;AAF7B,SAAA,MAAA;AACA,SAAA,UAAA;AACA,SAAA,UAAA;AAER,SAAK,QAAQ,KAAK,SAAQ;EAC5B;EAEA,IAAI,SAAM;AACR,WAAO,KAAK,MAAM;EACpB;EAEA,SAAS,MAAoB;AAC3B,WAAO,KAAK,MAAM,KAChB,OACE,EAAE,UAAU,KAAK,SACjB,EAAE,cAAc,KAAK,aACrB,EAAE,YAAY,KAAK,WACnB,EAAE,kBAAkB,KAAK,aAAa;EAE5C;EAEA,KAAK,MAAoB;AACvB,UAAM,YAAY,KAAK,MAAM,UAC3B,OACE,EAAE,UAAU,KAAK,SACjB,EAAE,cAAc,KAAK,aACrB,EAAE,YAAY,KAAK,WACnB,EAAE,kBAAkB,KAAK,aAAa;AAE1C,QAAI,cAAc,IAAI;AACpB,WAAK,MAAM,OAAO,WAAW,GAAG,IAAI;AACpC,WAAK,KAAI;;EAEb;EAEA,OAAO,MAAoB;AACzB,UAAM,YAAY,KAAK,MAAM,UAC3B,OACE,EAAE,UAAU,KAAK,SACjB,EAAE,cAAc,KAAK,aACrB,EAAE,YAAY,KAAK,WACnB,EAAE,kBAAkB,KAAK,aAAa;AAE1C,QAAI,cAAc,IAAI;AACpB,WAAK,MAAM,OAAO,WAAW,CAAC;AAC9B,WAAK,KAAI;;EAEb;EAEA,cAAW;AACT,WAAO,KAAK,MAAM,GAAG,EAAE;EACzB;EAEA,WAAQ;AACN,UAAM,MAAM,KAAK,QAAQ,IAAI,KAAK,GAAG;AACrC,QAAI,KAAK;AACP,aAAO,KAAK,MAAM,GAAG,EAAE,KAAK,GAAG;;AAEjC,WAAO,CAAA;EACT;EAEA,KAAK,MAAoB;AACvB,UAAM,QAAQ,CAAC,GAAG,KAAK,OAAO,IAAI;AAElC,QAAI,KAAK,WAAW,MAAM,SAAS,KAAK,SAAS;AAC/C,YAAM,MAAK;;AAGb,aAAS,WAAW,GAAG,WAAW,GAAG,YAAY;AAC/C,YAAM,WAAW,KAAK,QAAQ,IAC5B,KAAK,KACL,KAAK,UAAU,EAAE,CAAC,KAAK,GAAG,GAAG,MAAK,CAAE,CAAC;AAEvC,UAAI,EAAC,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU,QAAO;AACpB,aAAK,QAAQ;iBACJ,SAAS,gBAAgB,KAAK,SAAS;AAEhD,cAAM,MAAK;aACN;AACL;;;EAGN;EAEA,OAAI;AACF,SAAK,QAAQ,IAAI,KAAK,KAAK,KAAK,UAAU,EAAE,CAAC,KAAK,GAAG,GAAG,KAAK,MAAK,CAAE,CAAC;EACvE;;;;AChGF,IAAM,iBAAiB;AAEjB,IAAO,eAAP,MAAmB;EAKvB,YAAoB,SAA6B,kBAAwB;AAArD,SAAA,UAAA;AAA6B,SAAA,mBAAA;AAuDjD,SAAA,gBAAgB,CACd,OACA,WACA,SACA,kBACE;AACF,UACE,KAAK,gBACH,OACA,WACA,SACA,KAAK,QAAQ,YAAW,CAAE,GAE5B;AACA,aAAK,QAAQ,KAAK;UAChB;UACA;UACA;UACA;SACD;AACD,cAAM,iBAAiB,KAAK,QAAQ;AACpC,cAAM,kBAAkB,KAAK,SAAS;AACtC,aAAK,UAAU,eAAe,OAAO,eAAe;;IAExD;AA9EE,SAAK,UAAU,IAAI,WACjB,WACA,KAAK,SACL,KAAK,gBAAgB;AAGvB,SAAK,WAAW,IAAI,WAAW,aAAa,KAAK,SAAS,IAAI;AAE9D,SAAK,UAAU,CAAC,GAAG,KAAK,QAAQ,SAAQ,GAAI,GAAG,KAAK,SAAS,SAAQ,CAAE;EACzE;EAEQ,gBACN,OACA,WACA,SACA,gBAA+B;AAE/B,QAAI,CAAC,OAAO;AACV,aAAO;;AAGT,QAAI;AACF,YAAM,KAAK;aACX,IAAM;AACN,aAAO;;AAIT,QAAI,MAAM,SAAS,gBAAgB;AACjC,aAAO;;AAET,QAAI,CAAC,gBAAgB;AACnB,aAAO;;AAET,QAAI,KAAK,UAAU,KAAK,MAAM,KAAK,UAAU,eAAe,KAAK,GAAG;AAClE,UACE,KAAK,UAAU,SAAS,MAAM,KAAK,UAAU,eAAe,SAAS,GACrE;AACA,YACE,KAAK,UAAU,OAAO,MAAM,KAAK,UAAU,eAAe,OAAO,GACjE;AACA,iBAAO;;AAET,YAAI,WAAW,CAAC,eAAe,SAAS;AACtC,iBAAO;;;AAGX,UAAI,aAAa,CAAC,eAAe,WAAW;AAC1C,eAAO;;;AAGX,WAAO;EACT;EA4BA,eACE,OACA,WACA,SACA,eACA,OACA,UAAkB;AAElB,UAAM,OAAuB;MAC3B;MACA;MACA;MACA;MACA;;AAEF,QAAI,CAAC,KAAK,SAAS,SAAS,IAAI,GAAG;AACjC,WAAK,WAAW;AAChB,WAAK,SAAS,KAAK,IAAI;eACd,UAAU;AACnB,WAAK,WAAW;AAChB,WAAK,SAAS,OAAO,IAAI;;AAE3B,SAAK,UAAU,CAAC,GAAG,KAAK,QAAQ,OAAO,GAAG,KAAK,SAAS,KAAK;EAC/D;EAEA,UACE,OACA,WACA,SACA,eACA,OACA,UAAkB;AAElB,UAAM,OAAO;MACX;MACA;MACA;MACA;MACA;;AAEF,QAAI,UAAU;AACZ,WAAK,SAAS,KAAI,OAAA,OAAA,OAAA,OAAA,CAAA,GAAM,IAAI,GAAA,EAAE,SAAQ,CAAA,CAAA;WACjC;AACL,WAAK,QAAQ,KAAK,IAAI;;AAExB,SAAK,UAAU,CAAC,GAAG,KAAK,QAAQ,OAAO,GAAG,KAAK,SAAS,KAAK;EAC/D;;",
  "names": ["e", "t", "n", "r", "i", "l", "o", "isAsyncIterable", "__awaiter", "isAsyncIterable", "e", "e"]
}
